package proto

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/v2/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	types "github.com/infobloxopen/protoc-gen-gorm/types"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	datatypes "gorm.io/datatypes"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type ClientORM struct {
	ClientUserId *uint64
	CreatedAt    int64
	Id           uint64
	Inn          string
	Name         string
	Ogrn         string
	OwnerFio     string
	Quota        int64
	UpdatedAt    int64
}

// TableName overrides the default tablename generated by GORM
func (ClientORM) TableName() string {
	return "clients"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Client) ToORM(ctx context.Context) (ClientORM, error) {
	to := ClientORM{}
	var err error
	if prehook, ok := interface{}(m).(ClientWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Quota = m.Quota
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.OwnerFio = m.OwnerFio
	to.Inn = m.Inn
	to.Ogrn = m.Ogrn
	if posthook, ok := interface{}(m).(ClientWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ClientORM) ToPB(ctx context.Context) (Client, error) {
	to := Client{}
	var err error
	if prehook, ok := interface{}(m).(ClientWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Quota = m.Quota
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.OwnerFio = m.OwnerFio
	to.Inn = m.Inn
	to.Ogrn = m.Ogrn
	if posthook, ok := interface{}(m).(ClientWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Client the arg will be the target, the caller the one being converted from

// ClientBeforeToORM called before default ToORM code
type ClientWithBeforeToORM interface {
	BeforeToORM(context.Context, *ClientORM) error
}

// ClientAfterToORM called after default ToORM code
type ClientWithAfterToORM interface {
	AfterToORM(context.Context, *ClientORM) error
}

// ClientBeforeToPB called before default ToPB code
type ClientWithBeforeToPB interface {
	BeforeToPB(context.Context, *Client) error
}

// ClientAfterToPB called after default ToPB code
type ClientWithAfterToPB interface {
	AfterToPB(context.Context, *Client) error
}

type ClientUserORM struct {
	Client    *ClientORM `gorm:"foreignKey:ClientUserId;references:Id"`
	ClientId  uint64
	CreatedAt int64
	Email     string
	Id        uint64
	Password  string
	UpdatedAt int64
	Username  string
}

// TableName overrides the default tablename generated by GORM
func (ClientUserORM) TableName() string {
	return "client_users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ClientUser) ToORM(ctx context.Context) (ClientUserORM, error) {
	to := ClientUserORM{}
	var err error
	if prehook, ok := interface{}(m).(ClientUserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ClientId = m.ClientId
	to.Email = m.Email
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.Password = m.Password
	to.Username = m.Username
	if m.Client != nil {
		tempClient, err := m.Client.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Client = &tempClient
	}
	if posthook, ok := interface{}(m).(ClientUserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ClientUserORM) ToPB(ctx context.Context) (ClientUser, error) {
	to := ClientUser{}
	var err error
	if prehook, ok := interface{}(m).(ClientUserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ClientId = m.ClientId
	to.Email = m.Email
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.Password = m.Password
	to.Username = m.Username
	if m.Client != nil {
		tempClient, err := m.Client.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Client = &tempClient
	}
	if posthook, ok := interface{}(m).(ClientUserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ClientUser the arg will be the target, the caller the one being converted from

// ClientUserBeforeToORM called before default ToORM code
type ClientUserWithBeforeToORM interface {
	BeforeToORM(context.Context, *ClientUserORM) error
}

// ClientUserAfterToORM called after default ToORM code
type ClientUserWithAfterToORM interface {
	AfterToORM(context.Context, *ClientUserORM) error
}

// ClientUserBeforeToPB called before default ToPB code
type ClientUserWithBeforeToPB interface {
	BeforeToPB(context.Context, *ClientUser) error
}

// ClientUserAfterToPB called after default ToPB code
type ClientUserWithAfterToPB interface {
	AfterToPB(context.Context, *ClientUser) error
}

type AdminORM struct {
	CreatedAt int64
	Email     string
	Id        uint64
	Password  string
	UpdatedAt int64
	Username  string
}

// TableName overrides the default tablename generated by GORM
func (AdminORM) TableName() string {
	return "admins"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Admin) ToORM(ctx context.Context) (AdminORM, error) {
	to := AdminORM{}
	var err error
	if prehook, ok := interface{}(m).(AdminWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.Password = m.Password
	to.Username = m.Username
	if posthook, ok := interface{}(m).(AdminWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AdminORM) ToPB(ctx context.Context) (Admin, error) {
	to := Admin{}
	var err error
	if prehook, ok := interface{}(m).(AdminWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.Password = m.Password
	to.Username = m.Username
	if posthook, ok := interface{}(m).(AdminWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Admin the arg will be the target, the caller the one being converted from

// AdminBeforeToORM called before default ToORM code
type AdminWithBeforeToORM interface {
	BeforeToORM(context.Context, *AdminORM) error
}

// AdminAfterToORM called after default ToORM code
type AdminWithAfterToORM interface {
	AfterToORM(context.Context, *AdminORM) error
}

// AdminBeforeToPB called before default ToPB code
type AdminWithBeforeToPB interface {
	BeforeToPB(context.Context, *Admin) error
}

// AdminAfterToPB called after default ToPB code
type AdminWithAfterToPB interface {
	AfterToPB(context.Context, *Admin) error
}

type DataRecognitionTaskORM struct {
	Client                     *ClientORM `gorm:"foreignKey:ClientId;references:Id"`
	ClientId                   *uint64
	CreatedAt                  *time.Time
	Error                      string
	FrontendResultUnrecognized *types.Jsonb   `gorm:"type:jsonb"`
	Id                         string         `gorm:"type:uuid;primaryKey"`
	ProcessedImages            pq.StringArray `gorm:"type:text[]"`
	Result                     *datatypes.JSONType[TreeNode]
	SourceImages               pq.StringArray `gorm:"type:text[]"`
	Status                     int32
	StatusText                 string
	UpdatedAt                  *time.Time
	WorkerId                   string
}

// TableName overrides the default tablename generated by GORM
func (DataRecognitionTaskORM) TableName() string {
	return "data_recognition_tasks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DataRecognitionTask) ToORM(ctx context.Context) (DataRecognitionTaskORM, error) {
	to := DataRecognitionTaskORM{}
	var err error
	if prehook, ok := interface{}(m).(DataRecognitionTaskWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Client != nil {
		tempClient, err := m.Client.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Client = &tempClient
	}
	to.Status = int32(m.Status)
	to.Error = m.Error
	to.WorkerId = m.WorkerId
	to.StatusText = m.StatusText
	if m.SourceImages != nil {
		to.SourceImages = make(pq.StringArray, len(m.SourceImages))
		copy(to.SourceImages, m.SourceImages)
	}
	if m.ProcessedImages != nil {
		to.ProcessedImages = make(pq.StringArray, len(m.ProcessedImages))
		copy(to.ProcessedImages, m.ProcessedImages)
	}
	if m.FrontendResultUnrecognized != nil {
		to.FrontendResultUnrecognized = &types.Jsonb{[]byte(m.FrontendResultUnrecognized.Value)}
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(DataRecognitionTaskWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DataRecognitionTaskORM) ToPB(ctx context.Context) (DataRecognitionTask, error) {
	to := DataRecognitionTask{}
	var err error
	if prehook, ok := interface{}(m).(DataRecognitionTaskWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Client != nil {
		tempClient, err := m.Client.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Client = &tempClient
	}
	to.Status = Status(m.Status)
	to.Error = m.Error
	to.WorkerId = m.WorkerId
	to.StatusText = m.StatusText
	if m.SourceImages != nil {
		to.SourceImages = make(pq.StringArray, len(m.SourceImages))
		copy(to.SourceImages, m.SourceImages)
	}
	if m.ProcessedImages != nil {
		to.ProcessedImages = make(pq.StringArray, len(m.ProcessedImages))
		copy(to.ProcessedImages, m.ProcessedImages)
	}
	if m.FrontendResultUnrecognized != nil {
		to.FrontendResultUnrecognized = &types.JSONValue{Value: string(m.FrontendResultUnrecognized.RawMessage)}
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(DataRecognitionTaskWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DataRecognitionTask the arg will be the target, the caller the one being converted from

// DataRecognitionTaskBeforeToORM called before default ToORM code
type DataRecognitionTaskWithBeforeToORM interface {
	BeforeToORM(context.Context, *DataRecognitionTaskORM) error
}

// DataRecognitionTaskAfterToORM called after default ToORM code
type DataRecognitionTaskWithAfterToORM interface {
	AfterToORM(context.Context, *DataRecognitionTaskORM) error
}

// DataRecognitionTaskBeforeToPB called before default ToPB code
type DataRecognitionTaskWithBeforeToPB interface {
	BeforeToPB(context.Context, *DataRecognitionTask) error
}

// DataRecognitionTaskAfterToPB called after default ToPB code
type DataRecognitionTaskWithAfterToPB interface {
	AfterToPB(context.Context, *DataRecognitionTask) error
}

// DefaultCreateClient executes a basic gorm create call
func DefaultCreateClient(ctx context.Context, in *Client, db *gorm.DB) (*Client, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ClientORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadClient(ctx context.Context, in *Client, db *gorm.DB) (*Client, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ClientORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ClientORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ClientORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteClient(ctx context.Context, in *Client, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ClientORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ClientORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteClientSet(ctx context.Context, in []*Client, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ClientORM{})).(ClientORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ClientORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ClientORM{})).(ClientORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ClientORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Client, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Client, *gorm.DB) error
}

// DefaultStrictUpdateClient clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateClient(ctx context.Context, in *Client, db *gorm.DB) (*Client, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateClient")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ClientORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ClientORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchClient executes a basic gorm update call with patch behavior
func DefaultPatchClient(ctx context.Context, in *Client, updateMask *field_mask.FieldMask, db *gorm.DB) (*Client, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Client
	var err error
	if hook, ok := interface{}(&pbObj).(ClientWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadClient(ctx, &Client{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ClientWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskClient(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ClientWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateClient(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ClientWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ClientWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Client, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ClientWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Client, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ClientWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Client, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ClientWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Client, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetClient executes a bulk gorm update call with patch behavior
func DefaultPatchSetClient(ctx context.Context, objects []*Client, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Client, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Client, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchClient(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskClient patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskClient(ctx context.Context, patchee *Client, patcher *Client, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Client, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Quota" {
			patchee.Quota = patcher.Quota
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"OwnerFio" {
			patchee.OwnerFio = patcher.OwnerFio
			continue
		}
		if f == prefix+"Inn" {
			patchee.Inn = patcher.Inn
			continue
		}
		if f == prefix+"Ogrn" {
			patchee.Ogrn = patcher.Ogrn
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListClient executes a gorm list call
func DefaultListClient(ctx context.Context, db *gorm.DB) ([]*Client, error) {
	in := Client{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ClientORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Client{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ClientORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ClientORM) error
}

// DefaultCreateClientUser executes a basic gorm create call
func DefaultCreateClientUser(ctx context.Context, in *ClientUser, db *gorm.DB) (*ClientUser, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ClientUserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadClientUser(ctx context.Context, in *ClientUser, db *gorm.DB) (*ClientUser, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ClientUserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ClientUserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ClientUserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteClientUser(ctx context.Context, in *ClientUser, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ClientUserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ClientUserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteClientUserSet(ctx context.Context, in []*ClientUser, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ClientUserORM{})).(ClientUserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ClientUserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ClientUserORM{})).(ClientUserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ClientUserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ClientUser, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ClientUser, *gorm.DB) error
}

// DefaultStrictUpdateClientUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateClientUser(ctx context.Context, in *ClientUser, db *gorm.DB) (*ClientUser, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateClientUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ClientUserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterClient := ClientORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterClient.ClientUserId = new(uint64)
	*filterClient.ClientUserId = ormObj.Id
	if err = db.Where(filterClient).Delete(ClientORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ClientUserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchClientUser executes a basic gorm update call with patch behavior
func DefaultPatchClientUser(ctx context.Context, in *ClientUser, updateMask *field_mask.FieldMask, db *gorm.DB) (*ClientUser, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ClientUser
	var err error
	if hook, ok := interface{}(&pbObj).(ClientUserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadClientUser(ctx, &ClientUser{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ClientUserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskClientUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ClientUserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateClientUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ClientUserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ClientUserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ClientUser, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ClientUserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ClientUser, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ClientUserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ClientUser, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ClientUserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ClientUser, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetClientUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetClientUser(ctx context.Context, objects []*ClientUser, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ClientUser, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ClientUser, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchClientUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskClientUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskClientUser(ctx context.Context, patchee *ClientUser, patcher *ClientUser, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ClientUser, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedClient bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ClientId" {
			patchee.ClientId = patcher.ClientId
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if !updatedClient && strings.HasPrefix(f, prefix+"Client.") {
			updatedClient = true
			if patcher.Client == nil {
				patchee.Client = nil
				continue
			}
			if patchee.Client == nil {
				patchee.Client = &Client{}
			}
			if o, err := DefaultApplyFieldMaskClient(ctx, patchee.Client, patcher.Client, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Client.", db); err != nil {
				return nil, err
			} else {
				patchee.Client = o
			}
			continue
		}
		if f == prefix+"Client" {
			updatedClient = true
			patchee.Client = patcher.Client
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListClientUser executes a gorm list call
func DefaultListClientUser(ctx context.Context, db *gorm.DB) ([]*ClientUser, error) {
	in := ClientUser{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ClientUserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ClientUserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ClientUser{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ClientUserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ClientUserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ClientUserORM) error
}

// DefaultCreateAdmin executes a basic gorm create call
func DefaultCreateAdmin(ctx context.Context, in *Admin, db *gorm.DB) (*Admin, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AdminORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAdmin(ctx context.Context, in *Admin, db *gorm.DB) (*Admin, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AdminORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AdminORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AdminORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAdmin(ctx context.Context, in *Admin, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AdminORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AdminORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAdminSet(ctx context.Context, in []*Admin, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AdminORM{})).(AdminORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AdminORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AdminORM{})).(AdminORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AdminORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Admin, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Admin, *gorm.DB) error
}

// DefaultStrictUpdateAdmin clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAdmin(ctx context.Context, in *Admin, db *gorm.DB) (*Admin, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAdmin")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AdminORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AdminORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAdmin executes a basic gorm update call with patch behavior
func DefaultPatchAdmin(ctx context.Context, in *Admin, updateMask *field_mask.FieldMask, db *gorm.DB) (*Admin, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Admin
	var err error
	if hook, ok := interface{}(&pbObj).(AdminWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAdmin(ctx, &Admin{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AdminWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAdmin(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AdminWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAdmin(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AdminWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AdminWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Admin, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AdminWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Admin, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AdminWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Admin, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AdminWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Admin, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAdmin executes a bulk gorm update call with patch behavior
func DefaultPatchSetAdmin(ctx context.Context, objects []*Admin, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Admin, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Admin, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAdmin(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAdmin patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAdmin(ctx context.Context, patchee *Admin, patcher *Admin, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Admin, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAdmin executes a gorm list call
func DefaultListAdmin(ctx context.Context, db *gorm.DB) ([]*Admin, error) {
	in := Admin{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AdminORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AdminORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Admin{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AdminORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AdminORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AdminORM) error
}

// DefaultCreateDataRecognitionTask executes a basic gorm create call
func DefaultCreateDataRecognitionTask(ctx context.Context, in *DataRecognitionTask, db *gorm.DB) (*DataRecognitionTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DataRecognitionTaskORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDataRecognitionTask(ctx context.Context, in *DataRecognitionTask, db *gorm.DB) (*DataRecognitionTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DataRecognitionTaskORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DataRecognitionTaskORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DataRecognitionTaskORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDataRecognitionTask(ctx context.Context, in *DataRecognitionTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DataRecognitionTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DataRecognitionTaskORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDataRecognitionTaskSet(ctx context.Context, in []*DataRecognitionTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DataRecognitionTaskORM{})).(DataRecognitionTaskORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DataRecognitionTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DataRecognitionTaskORM{})).(DataRecognitionTaskORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DataRecognitionTaskORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DataRecognitionTask, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DataRecognitionTask, *gorm.DB) error
}

// DefaultStrictUpdateDataRecognitionTask clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDataRecognitionTask(ctx context.Context, in *DataRecognitionTask, db *gorm.DB) (*DataRecognitionTask, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDataRecognitionTask")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DataRecognitionTaskORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DataRecognitionTaskORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDataRecognitionTask executes a basic gorm update call with patch behavior
func DefaultPatchDataRecognitionTask(ctx context.Context, in *DataRecognitionTask, updateMask *field_mask.FieldMask, db *gorm.DB) (*DataRecognitionTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DataRecognitionTask
	var err error
	if hook, ok := interface{}(&pbObj).(DataRecognitionTaskWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDataRecognitionTask(ctx, &DataRecognitionTask{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DataRecognitionTaskWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDataRecognitionTask(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DataRecognitionTaskWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDataRecognitionTask(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DataRecognitionTaskWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DataRecognitionTaskWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DataRecognitionTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DataRecognitionTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DataRecognitionTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DataRecognitionTask, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDataRecognitionTask executes a bulk gorm update call with patch behavior
func DefaultPatchSetDataRecognitionTask(ctx context.Context, objects []*DataRecognitionTask, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DataRecognitionTask, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DataRecognitionTask, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDataRecognitionTask(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDataRecognitionTask patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDataRecognitionTask(ctx context.Context, patchee *DataRecognitionTask, patcher *DataRecognitionTask, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DataRecognitionTask, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedClient bool
	var updatedRecognitionResult bool
	var updatedFrontendResult bool
	var updatedFrontendResultUnrecognized bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedClient && strings.HasPrefix(f, prefix+"Client.") {
			updatedClient = true
			if patcher.Client == nil {
				patchee.Client = nil
				continue
			}
			if patchee.Client == nil {
				patchee.Client = &Client{}
			}
			if o, err := DefaultApplyFieldMaskClient(ctx, patchee.Client, patcher.Client, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Client.", db); err != nil {
				return nil, err
			} else {
				patchee.Client = o
			}
			continue
		}
		if f == prefix+"Client" {
			updatedClient = true
			patchee.Client = patcher.Client
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Error" {
			patchee.Error = patcher.Error
			continue
		}
		if f == prefix+"WorkerId" {
			patchee.WorkerId = patcher.WorkerId
			continue
		}
		if f == prefix+"StatusText" {
			patchee.StatusText = patcher.StatusText
			continue
		}
		if f == prefix+"SourceImages" {
			patchee.SourceImages = patcher.SourceImages
			continue
		}
		if f == prefix+"ProcessedImages" {
			patchee.ProcessedImages = patcher.ProcessedImages
			continue
		}
		if !updatedRecognitionResult && strings.HasPrefix(f, prefix+"RecognitionResult.") {
			if patcher.RecognitionResult == nil {
				patchee.RecognitionResult = nil
				continue
			}
			if patchee.RecognitionResult == nil {
				patchee.RecognitionResult = &TreeNode{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RecognitionResult."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RecognitionResult, patchee.RecognitionResult, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RecognitionResult" {
			updatedRecognitionResult = true
			patchee.RecognitionResult = patcher.RecognitionResult
			continue
		}
		if !updatedFrontendResult && strings.HasPrefix(f, prefix+"FrontendResult.") {
			if patcher.FrontendResult == nil {
				patchee.FrontendResult = nil
				continue
			}
			if patchee.FrontendResult == nil {
				patchee.FrontendResult = &TreeNode{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FrontendResult."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.FrontendResult, patchee.FrontendResult, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FrontendResult" {
			updatedFrontendResult = true
			patchee.FrontendResult = patcher.FrontendResult
			continue
		}
		if !updatedFrontendResultUnrecognized && strings.HasPrefix(f, prefix+"FrontendResultUnrecognized") {
			patchee.FrontendResultUnrecognized = patcher.FrontendResultUnrecognized
			updatedFrontendResultUnrecognized = true
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDataRecognitionTask executes a gorm list call
func DefaultListDataRecognitionTask(ctx context.Context, db *gorm.DB) ([]*DataRecognitionTask, error) {
	in := DataRecognitionTask{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DataRecognitionTaskORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataRecognitionTaskORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DataRecognitionTask{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DataRecognitionTaskORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataRecognitionTaskORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DataRecognitionTaskORM) error
}
